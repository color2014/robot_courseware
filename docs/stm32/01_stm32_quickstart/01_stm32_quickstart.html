



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="传智专修学院 人工智能和机器人实验室 正则表达式">
      
      
        <link rel="canonical" href="https://www.czxy.com/docs/01_stm32_quickstart/">
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../assets/favicon.ico">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-4.6.3">
    
    
      
        <title>快速入门 - 黑马机器人—STM32！</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.adb8469c.css">
      
      
    
    
      <script src="../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#_1" tabindex="0" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <!-- <a href="https://www.czxy.com/docs" title="黑马机器人—STM32！" aria-label="黑马机器人—STM32！" class="md-header-nav__button md-logo"> -->
        <a href="/" title="黑马机器人—STM32！" aria-label="黑马机器人—STM32！" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              <a href="https://www.czxy.com/docs">黑马机器人—STM32！</a>
            </span>
            <span class="md-header-nav__topic">
              
                快速入门
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer" style="display: none;">
    <a href="https://www.czxy.com/docs" title="黑马机器人—STM32！" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    黑马机器人—STM32！
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../00_intro/" title="课程介绍" class="md-nav__link">
      课程介绍
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../01_env/" title="环境搭建" class="md-nav__link">
      环境搭建
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        快速入门
      </label>
    
    <a href="./" title="快速入门" class="md-nav__link md-nav__link--active">
      快速入门
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    基础配置
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    选择芯片
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    打开串口调试
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    配置时钟
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-led" class="md-nav__link">
    1. 闪烁led灯
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    练一练
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2. 开关的使用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-usart" class="md-nav__link">
    3. USART通讯
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    简单收发
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    中断方式接收消息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#printf" class="md-nav__link">
    重定向printf
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    小技巧
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4. 搭建程序入口
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../02_motor/" title="驱动电机" class="md-nav__link">
      驱动电机
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../03_diff_2wd_driver/" title="差速运动" class="md-nav__link">
      差速运动
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../04_01_oled/" title="OLED显示" class="md-nav__link">
      OLED显示
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../04_02_ps2/" title="PS2控制" class="md-nav__link">
      PS2控制
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../04_03_blueth/" title="蓝牙控制" class="md-nav__link">
      蓝牙控制
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../04_04_i2c/" title="I2C通讯" class="md-nav__link">
      I2C通讯
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../05_custom_serial/" title="串口通讯" class="md-nav__link">
      串口通讯
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    基础配置
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    选择芯片
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    打开串口调试
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    配置时钟
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-led" class="md-nav__link">
    1. 闪烁led灯
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    练一练
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2. 开关的使用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-usart" class="md-nav__link">
    3. USART通讯
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    简单收发
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    中断方式接收消息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#printf" class="md-nav__link">
    重定向printf
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    小技巧
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4. 搭建程序入口
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="_1">快速入门<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<p>学习任何一门技术,其实都需要练习.本章我们将采用案例驱动的方式来带领大家学习STM32, 我们首先需要对我们的工程做一个基础的配置.</p>
<p>不管做什么案例,我们都需要对芯片做一些基础配置</p>
<h2 id="_2">基础配置<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<h3 id="_3">选择芯片<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>大家打开CubeMX,然后选择新建工程,在MPU选择的这个输入框中输入<code>STM32F103VE</code>然后根据提示双击右下方的<code>STM32F103VET6</code>,这样我们的芯片就选择好啦!</p>
<p><img alt="" src="../img/env1.jpg" /></p>
<p>选择好芯片之后, 界面如下图所示</p>
<p><img alt="" src="../img/env2.jpg" /></p>
<h3 id="_4">打开串口调试<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>为了能够让代码烧写到芯片中,我们需要打开串口调试功能.操作流程如下图所示</p>
<p><img alt="" src="../img/env3.jpg" /></p>
<h3 id="_5">配置时钟<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>单片机的时钟如同人的心脏一样重要, 例如我们将单片的时钟设置为<code>72M</code>, 它的含义就是让单片机<code>1</code>秒钟执行<code>72000,000</code> 次.    如果我们利用时钟来计数, 单片机时钟每跳动一次, 计数值<code>+1</code>, 那么1秒钟之后,这个数就是<code>72000,000</code>.  也就是时钟每跳动一次,就执行一行代码.</p>
<p>所以我们是把时钟配置快一点好,还是慢一点好呢?  当然是要快一点啊!</p>
<p>参照如下图, 我们打开高速时钟和低速时钟配置</p>
<p><img alt="" src="../img/env4.jpg" /></p>
<p>然后打开<code>Clock Configuration</code> 配置,在<code>HCLK</code> 中输入72,然后按<code>回车键</code>, 此时程序会弹窗询问你是否让程序自动配置其它的配置, 单击<code>OK确定</code>即可完成时钟的配置.</p>
<p>这里芯片最高支持<code>72M</code>,所以我们填入最高配置即可.</p>
<p><img alt="" src="../img/env5.jpg" /></p>
<p>至此,我们就完成了芯片的基础配置. 后续无论做什么什么案例,这个配置都是需要的.</p>
<p>下面我们再按照下图的步骤,将我们的工程导出在Clion中去使用</p>
<p><img alt="" src="../img/env7.jpg" /></p>
<p>代码生成完成之后, 我们用Clion打开就可以对它进行编程啦!</p>
<h2 id="1-led">1. 闪烁led灯<a class="headerlink" href="#1-led" title="Permanent link">&para;</a></h2>
<p>这一小节,我们先来做一个简单的点亮LED灯案例, 要想控制单片机去驱动LED灯, 我们需要用到单片机的GPIO.</p>
<p>GPIO(General-purpose input/output)是通用型输入输出的简称，简单来说就是我们可以通过编程的方式来控制单片机引脚的输入与输出.</p>
<p><strong>输入</strong>就是读取单片机引脚的电平状态, 是高电平还是低电平. 我们把可以把5v理解为高电平, 0v理解为低电平.  </p>
<p><strong>输出</strong>就是我们控制IO的状态为高电平或者低电平.</p>
<p>下面我们就以点亮一个Led灯为例,来学习一下GPIO口的输出功能</p>
<p>我们首先打开CubeMX,设定PE10引脚为输出功能  </p>
<p><img alt="" src="../img/env6.jpg" /></p>
<p>演示效果如下:</p>
<p><img alt="" src="../img/env8.jpg" /></p>
<p>根据上面的这个电路图,在我们的这块PCB板子上,一共有3个LED灯, 然而只有<code>LED3</code>是连接在STM32上的PE10引脚, 所以我们控制PE10的IO状态就可以控制LED灯的亮灭. </p>
<p>按照电路图,LED的一端已经连接了高电平, 那么PE10这一端我们需要给它低电平,才能让灯亮起来</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code>HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_RESET);
</code></pre></div>
</td></tr></table>

<p>如果想让灯灭的话, 我们需要给PE10这一端设定为高电平</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code>HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_SET);
</code></pre></div>
</td></tr></table>

<p>如果想让LED间隔一定时间闪烁的话,我们可以采用如下的方式:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="c1">// 闪烁led灯</span>
<span class="n">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOA</span><span class="p">,</span><span class="n">GPIO_PIN_1</span><span class="p">,</span><span class="n">GPIO_PIN_SET</span><span class="p">);</span>
<span class="n">HAL_Delay</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
<span class="n">HAL_GPIO_WritePin</span><span class="p">(</span><span class="n">GPIOA</span><span class="p">,</span><span class="n">GPIO_PIN_1</span><span class="p">,</span><span class="n">GPIO_PIN_RESET</span><span class="p">);</span>
<span class="n">HAL_Delay</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</code></pre></div>
</td></tr></table>

<p>好啦,本小节我们就通过一个简单的LED灯带领大家学习了一些IO的输出控制.  </p>
<h4 id="_6">练一练<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<p>利用刚学过的内容,大家试一试能不能让我们PCB板上的蜂鸣器响起来呢 ?</p>
<p><img alt="" src="../img/env9.jpg" /></p>
<h2 id="2">2. 开关的使用<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<video  height="420" controls>
  <source src="../img/switch.mp4" type="video/mp4">
</video>

<p>本小节我们要给大家讲的是开关的使用,对于GPIO来说我们读取开关状态其实就是要读取IO口的电平变化.</p>
<p>下面我们先来看一下电路图,开关对应的是哪个引脚</p>
<p><img alt="" src="../img/env10.jpg" /></p>
<p>根据电路图,我们先通过CubeMx来设置工程,将PD8设置为<strong>输入模式</strong>, 设定好之后需要重新生成工程.</p>
<p><img alt="" src="../img/env11.jpg" /></p>
<p>默认情况下, PD8是高电平, 当开关按下之后,PD8就会变成低电平. 为了便于观看效果,所以我们就通过开关来控制LED灯的亮灭</p>
<p>我们首先来写一个测试代码</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code>// 读取状态
GPIO_PinState state = HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_8);
// 将读取到的值, 赋值给PE10
HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,state);
</code></pre></div>
</td></tr></table>

<p>我们发现LED灯并不亮,间接的证明了PD10默认是高电平. 当我们将按键按下的时候, PD8变为低电平, 然后LED3亮起来了.这就是我们通过开关控制了LED灯.</p>
<p>但是这种控制方式,其实是有弊端的, 当我们按下,手指没有抬起的时候, 上面的逻辑会一直不停的运行, 这与我们开关的想法有差异, 我们希望手指按下开关到手指抬起, 开关的逻辑只执行一次,所以我们需要来解决这个问题. 下面给出了一段示例代码,大家可以分析一下.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code>    <span class="c1">// 读取IO口的电平状态</span>
    <span class="n">GPIO_PinState</span> <span class="n">state</span> <span class="o">=</span> <span class="n">HAL_GPIO_ReadPin</span><span class="p">(</span><span class="n">GPIOC</span><span class="p">,</span><span class="n">GPIO_PIN_14</span><span class="p">);</span>
    <span class="c1">// 默认为输入高电平,当按键按下时读到就是低电平</span>
    <span class="k">if</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">GPIO_PIN_RESET</span><span class="p">){</span>
        <span class="c1">// 防止按键抖动,用户误操作</span>
        <span class="n">HAL_Delay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
        <span class="c1">// 确保万无一失,再次读取</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">HAL_GPIO_ReadPin</span><span class="p">(</span><span class="n">GPIOC</span><span class="p">,</span><span class="n">GPIO_PIN_14</span><span class="p">)){</span>
            <span class="c1">// 切换LED灯的状态</span>
            <span class="n">HAL_GPIO_TogglePin</span><span class="p">(</span><span class="n">GPIOC</span><span class="p">,</span><span class="n">GPIO_PIN_13</span><span class="p">);</span>
            <span class="c1">// 直到用户按键抬起才算一次按键结束</span>
            <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">HAL_GPIO_ReadPin</span><span class="p">(</span><span class="n">GPIOC</span><span class="p">,</span><span class="n">GPIO_PIN_14</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
</td></tr></table>

<h2 id="3-usart">3. USART通讯<a class="headerlink" href="#3-usart" title="Permanent link">&para;</a></h2>
<p>由于STM32编程不能像我们之前编程一样很直观的输出<code>Hello World!</code>,这里我们首先来教大家如何通过串口通讯输出日志.我们这里首先要给大家介绍的是USART</p>
<p>USART:(Universal Synchronous/Asynchronous Receiver/Transmitter) 通用同步/异步串行接收/发送器,USART 是一个全双工通用同步/异步串行收发模块，该接口是一个高度灵活的串行通信设备  </p>
<h3 id="_7">简单收发<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>这里为了简单演示,我们先采用阻塞的方式进行数据的收发, 我们首先需要在Cubemx中打开串口通讯接口</p>
<p><img alt="" src="../img/env12.jpg" /></p>
<p>同样的配置完成之后,我们需要重新生成代码.</p>
<ul>
<li>发送消息</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="kt">char</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;hello world!</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">HAL_UART_Transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">3000</span><span class="p">);</span>
</code></pre></div>
</td></tr></table>

<ul>
<li>接收消息</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>      
<span class="n">HAL_UART_Receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">3000</span><span class="p">);</span>

<span class="n">HAL_UART_Transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">3000</span><span class="p">);</span><span class="n">HAL_UART_Receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span><span class="n">ch</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</code></pre></div>
</td></tr></table>

<h3 id="_8">中断方式接收消息<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p>中断是指计算机运行过程中，出现某些特殊情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
<p>对于我们程序的中断来说,我们可以把单片机看成是一个主循环, 当中断发生的时候, 程序跳转去执行中断程序,当中断程序执行完成之后, 单片机又继续去执行主循环.</p>
<p><img alt="" src="../img/env13.jpg" /></p>
<p>要想使用中断的方式进行接收,我们需要在cubemx中开启中断,然后实现中断回调函数</p>
<p><img alt="" src="../img/env14.jpg" /></p>
<p>接下来我们就可以使用中断的方式来接收数据了, 我们先在全局声明一个数组容器:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="kt">uint8_t</span> <span class="n">rx_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div>
</td></tr></table>

<p>容器的大小我指定为1的意思,当接收到1个字节数据, 程序就进入中断处理函数,我们需要在程序中将这个<code>void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</code>函数重写</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">HAL_UART_RxCpltCallback</span><span class="p">(</span><span class="n">UART_HandleTypeDef</span> <span class="o">*</span><span class="n">huart</span><span class="p">){</span>
    <span class="c1">// 将接收到的内容重新发送出去</span>
    <span class="n">HAL_UART_Transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span><span class="n">rx_data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3000</span><span class="p">);</span>
    <span class="c1">// 需要重新使能中断接收</span>
    <span class="n">HAL_UART_Receive_IT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span><span class="p">,</span><span class="n">rx_data</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</td></tr></table>

<p>上面工作做完之后,我们就可以在main函数中首次使能中断接收</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code>HAL_UART_Receive_IT(&amp;huart2,RX,1);
</code></pre></div>
</td></tr></table>

<p><img alt="" src="../img/env15.jpg" /></p>
<p>从实验结果我们可以看出, 每次发送一个字节的数据出去, 单片机都立马返回了一字节的数据回来.</p>
<h3 id="printf">重定向printf<a class="headerlink" href="#printf" title="Permanent link">&para;</a></h3>
<p>大家可能会发现上面的打印挺麻烦的.在STM32开发中我们其实也可以像C语言那样使用<code>printf</code>进行输出，只不过C语言中默认输出到控制台中，而stm32没有控制台，我们需要将它重定向到串口中，所用我们可以采用重写printf底层函数的方式来做。</p>
<p>大家只需将如下代码复制到我们工程中，即可使用<code>printf</code>将信息输出到串口中</p>
<p>注意： 这里需要引入头文件<code>#include &lt;stdio.h&gt;</code>,并且重定向的代码需要放到<strong>c文件</strong>中,<code>printf</code>本身就是c函数</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="cp">#ifdef __GNUC__</span>
<span class="cp">#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span>
<span class="cp">#else</span>
<span class="cp">#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span>
<span class="cp">#endif</span>
<span class="n">PUTCHAR_PROTOTYPE</span>
<span class="p">{</span>
    <span class="c1">// 参数1： 使用哪个usart ,参数2： 字符， 参数3：输出数量，参数4：超时等待时间</span>
    <span class="n">HAL_UART_Transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart1</span> <span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span> <span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
</td></tr></table>

<p>每次我们使用printf都需要在末尾街上<code>\r\n</code>换行,很麻烦.所以我们可以采用如下方案,进一步进行改写.</p>
<p>并且采用这种方式的好处就是,我们随时可以禁用日志打印功能</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="cp">#define LOG_ENABLE 1</span>
<span class="cp">#if LOG_ENABLE</span>
<span class="cp">#define log(format,...) printf(format&quot;\r\n&quot;,##__VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#define log(format,...)</span>
<span class="cp">#endif</span>
</code></pre></div>
</td></tr></table>

<p>如果想要使用printf输出浮点数的话，还需要做如下配置：</p>
<ol>
<li>修改CMakeLIst文件</li>
</ol>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code>SET<span class="o">(</span>COMMON_FLAGS
    <span class="s2">&quot;-mcpu=cortex-m3 </span><span class="si">${</span><span class="nv">FPU_FLAGS</span><span class="si">}</span><span class="s2"> -mthumb -mthumb-interwork -ffunction-sections -fdata-sections \</span>
<span class="s2">    -g -fno-common -fmessage-length=0 -specs=nosys.specs -specs=nano.specs -u _printf_float&quot;</span><span class="o">)</span>
</code></pre></div>
</td></tr></table>

<ol>
<li>如果仍然无法输出浮点数,就拷贝下面文件到Src目录中</li>
</ol>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code>/home/kaijun/STM32Cube/Repository/STM32Cube_FW_F1_V1.8.0/Projects/STM3210C_EVAL/Examples/UART/UART_Printf/syscalls.c
</code></pre></div>
</td></tr></table>

<p>这是因为我们所使用的库，默认是没有开启浮点数输出的.这里需要注意的是我们修改的是<code>CubeMX</code>工具自动生成的CMakeList,当我们重新使用CubeMX重新生成代码的时候,这里所做的所有修改都将会丢失.</p>
<p><strong>注意:改动完成之后,请在tools--&gt;Cmake--&gt;Reset Cache and Reload Project</strong></p>
<h4 id="_9">小技巧<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<p>如果想打印好看个性化的日志，可以访问这个网站http://patorjk.com/software/taag</p>
<p>我选择的字体为<code>Big</code> ,然后逐行将要打印的内容复制即可.</p>
<p>示例代码:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code>  <span class="n">log</span><span class="p">(</span><span class="s">&quot;  _   _     _              _                     &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot; (_) | |   | |            (_)                    &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot;  _  | |_  | |__     ___   _   _ __ ___     __ _ &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot; | | | __| | &#39;_ </span><span class="se">\\</span><span class="s">   / _ </span><span class="se">\\</span><span class="s"> | | | &#39;_ ` _ </span><span class="se">\\</span><span class="s">   / _` |&quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot; | | | |_  | | | | |  __/ | | | | | | | | | (_| |&quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot; |_|  </span><span class="se">\\</span><span class="s">__| |_| |_|  </span><span class="se">\\</span><span class="s">___| |_| |_|_|_| |_|  </span><span class="se">\\</span><span class="s">__,_|&quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot;                 _               _                  &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot;                | |             | |              &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot;  _ __    ___   | |__     ___   | |_             &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot; | &#39;__|  / _ </span><span class="se">\\</span><span class="s">  | &#39;_ </span><span class="se">\\</span><span class="s">   / _ </span><span class="se">\\</span><span class="s">  | __|            &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot; | |    | (_) | | |_) | | (_) | | |_             &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot; |_|     </span><span class="se">\\</span><span class="s">___/  |_.__/   </span><span class="se">\\</span><span class="s">___/   </span><span class="se">\\</span><span class="s">__|            &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot;                                                 &quot;</span><span class="p">);</span>
  <span class="n">log</span><span class="p">(</span><span class="s">&quot;itheima robot is started...&quot;</span><span class="p">);</span>
</code></pre></div>
</td></tr></table>

<p>输出效果:</p>
<p><img alt="" src="../img/log.png" /></p>
<h2 id="4">4. 搭建程序入口<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<p>我们使用cubemx生成的代码都是<code>.c</code>文件,非常不利于我们后面采用面向对象的方式进行编程,为了使用面向对象的cpp语言,我们需要定义这么一个cpp的头文件作为桥梁.</p>
<p><code>.c</code>文件中是无法直接使用cpp的类,所以我们需要想办法使用cpp来编程.下面这个文件很关键,它是告诉编译器,如果当前文件是cpp文件,就使用c的方式来编译这个文件. 这样我们就可以巧妙的让c文件能够去调用cpp中的函数啦!</p>
<ul>
<li>定义头文件<code>heimarobot.h</code></li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="c1">//</span>
<span class="c1">// Created by Kaijun on 2020/3/10.</span>
<span class="c1">//</span>

<span class="cp">#ifndef HEIMAROBOT_HEIMAROBOT_H</span>
<span class="cp">#define HEIMAROBOT_HEIMAROBOT_H</span>
<span class="c1">// 如果是cpp文件采用c文件的方式去编译下面的函数</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">HeimaRobotInit</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">HeimaRobotTick</span><span class="p">();</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="c1">//HEIMAROBOT_HEIMAROBOT_H</span>
</code></pre></div>
</td></tr></table>

<ul>
<li>实现头文件<code>heimarobot.cpp</code></li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">HeimaRobotInit</span><span class="p">(){</span>
    <span class="c1">// 实现一些功能的初始化</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">HeimaRobotTick</span><span class="p">(){</span>
    <span class="c1">// 实现主循环的功能</span>
<span class="p">}</span>
</code></pre></div>
</td></tr></table>

<ul>
<li>在main.c中调用函数</li>
</ul>
<p>引入上面我们写好的头文件,然后在main函数中主循环外面初始化我们自己写的函数<code>HeimaRobotInit()</code></p>
<p>在<code>while</code>循环中调用我们自己编写的<code>HeimaRobotTick()</code>函数</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="cm">/* USER CODE BEGIN 2 */</span>
<span class="n">HeimaRobotInit</span><span class="p">();</span>
<span class="cm">/* USER CODE END 2 */</span>

<span class="cm">/* Infinite loop */</span>
<span class="cm">/* USER CODE BEGIN WHILE */</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HeimaRobotTick</span><span class="p">();</span>
    <span class="cm">/* USER CODE END WHILE */</span>

    <span class="cm">/* USER CODE BEGIN 3 */</span>
<span class="p">}</span>
</code></pre></div>
</td></tr></table>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../01_env/" title="环境搭建" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                环境搭建
              </span>
            </div>
          </a>
        
        
          <a href="../02_motor/" title="驱动电机" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                驱动电机
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            <a href="https://www.czxy.com/">传智专修学院</a> 版权所有 2006 - 2020 江苏传智播客教育科技股份有限公司  学校地址：江苏省宿迁市沭阳县北京南路6号  邮编：223600   <a href="http://www.beian.miit.gov.cn/">苏ICP备16007882号-4</a>
          </div>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.c33a9706.js"></script>
      
        
        
          
          <script src="../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
              
            
          
          
        
      
      <script>app.initialize({version:"1.1",url:{base:".."}})</script>
      
        <script src="../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
        <script src="../js/baidu-tongji.js"></script>
      
    
  </body>
</html>