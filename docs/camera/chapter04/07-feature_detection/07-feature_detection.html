



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="相机标定 物体检测 3d相机原理 双目相机 结构光相机 TOF相机 三维扫描仪 3D相机编程 相机标定 去畸变 位姿估计 三维重建 相机模型 小孔成像模型">
      
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../../assets/favicon.ico">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-4.6.3">
    
    
      
        <title>07-实现特征检测及描述 - 黑马机器人 | 相机标定&物体检测</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.adb8469c.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#07-" tabindex="0" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <!-- <a href="../.." title="黑马机器人 | 相机标定&物体检测" aria-label="黑马机器人 | 相机标定&物体检测" class="md-header-nav__button md-logo"> -->
        <a href="/docs" title="黑马机器人 | 相机标定&物体检测" aria-label="黑马机器人 | 相机标定&物体检测" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              <a href="../..">黑马机器人 | 相机标定&物体检测</a>
            </span>
            <span class="md-header-nav__topic">
              
                07-实现特征检测及描述
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer" style="display: none;">
    <a href="../.." title="黑马机器人 | 相机标定&物体检测" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    黑马机器人 | 相机标定&物体检测
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      一、相机基础知识
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        一、相机基础知识
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter01/" title="学习目标" class="md-nav__link">
      学习目标
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter01/01-camera/" title="01-相机基础" class="md-nav__link">
      01-相机基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter01/02-3D_camera/" title="02-3D相机及分类" class="md-nav__link">
      02-3D相机及分类
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter01/03-pinhole_camera_model/" title="03-相机模型" class="md-nav__link">
      03-相机模型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter01/04-coordinates/" title="04-坐标变换" class="md-nav__link">
      04-坐标变换
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter01/05-distortions/" title="05-相机透镜及畸变" class="md-nav__link">
      05-相机透镜及畸变
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter01/06-undistortion/" title="06-相机标定与去畸变" class="md-nav__link">
      06-相机标定与去畸变
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      二、相机标定&去畸变
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        二、相机标定&去畸变
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter02/" title="学习目标" class="md-nav__link">
      学习目标
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter02/01-calibration_board/" title="01-相机标定&标定板" class="md-nav__link">
      01-相机标定&标定板
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter02/02-calibration_camera/" title="02-标定实现" class="md-nav__link">
      02-标定实现
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter02/03-undistortion/" title="03-去畸变(矫正)" class="md-nav__link">
      03-去畸变(矫正)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter02/04-pose_estimation/" title="04-位置估计及3D重建" class="md-nav__link">
      04-位置估计及3D重建
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter02/exercise/" title="作业" class="md-nav__link">
      作业
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      三、双目相机原理与应用
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        三、双目相机原理与应用
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter03/" title="学习目标" class="md-nav__link">
      学习目标
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter03/01-stereo_theory/" title="01-双目相机原理" class="md-nav__link">
      01-双目相机原理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter03/02-stereo_drivers/" title="02-双目相机驱动" class="md-nav__link">
      02-双目相机驱动
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter03/03-stereo_calibration/" title="03-双目相机标定" class="md-nav__link">
      03-双目相机标定
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter03/04-stereo_point_cloud/" title="04-双目相机生成点云" class="md-nav__link">
      04-双目相机生成点云
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../chapter03/05-stereo_other/" title="05-其他操作" class="md-nav__link">
      05-其他操作
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      四、2D图像处理实战
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        四、2D图像处理实战
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="学习目标" class="md-nav__link">
      学习目标
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../01-obj_detect/" title="01-物体检测概述" class="md-nav__link">
      01-物体检测概述
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../02-line_detect/" title="02-直线检测" class="md-nav__link">
      02-直线检测
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../03-box_detect/" title="03-牙膏盒检测" class="md-nav__link">
      03-牙膏盒检测
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../04-common_detect/" title="04-多阈值检测多边形" class="md-nav__link">
      04-多阈值检测多边形
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../05-template_match/" title="05-模板匹配多个物体" class="md-nav__link">
      05-模板匹配多个物体
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../06-feature_detection_description/" title="06-特征检测及描述" class="md-nav__link">
      06-特征检测及描述
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../07-corner_detection/" title="07-角点检测" class="md-nav__link">
      07-角点检测
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        07-实现特征检测及描述
      </label>
    
    <a href="./" title="07-实现特征检测及描述" class="md-nav__link md-nav__link--active">
      07-实现特征检测及描述
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    特征点检测
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    特征点检测方法分类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    特征点的要求
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sift" class="md-nav__link">
    SIFT尺度不变特征变换
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#surf" class="md-nav__link">
    SURF加速鲁棒特征
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#surf_1" class="md-nav__link">
    SURF检测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#u-surf" class="md-nav__link">
    U-SURF检测
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#orb" class="md-nav__link">
    ORB特征检测
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fast" class="md-nav__link">
    FAST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#brief" class="md-nav__link">
    BRIEF
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    尺度和旋转不变性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    特征匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    文档参考
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../08-feature_matching/" title="08-特征匹配" class="md-nav__link">
      08-特征匹配
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../09-feature_matching2/" title="09-使用特征匹配查找目标" class="md-nav__link">
      09-使用特征匹配查找目标
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../10-feature_matching3/" title="10-特征匹配恢复目标" class="md-nav__link">
      10-特征匹配恢复目标
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../exercise/" title="作业&练习" class="md-nav__link">
      作业&练习
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      附录：相关开发环境
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        附录：相关开发环境
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../env/" title="前言" class="md-nav__link">
      前言
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../env/01-opencv/" title="编译安装OpenCV依赖库" class="md-nav__link">
      编译安装OpenCV依赖库
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../env/02-CMakeLists/" title="CMakeLists配置模板" class="md-nav__link">
      CMakeLists配置模板
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    特征点检测
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    特征点检测方法分类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    特征点的要求
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sift" class="md-nav__link">
    SIFT尺度不变特征变换
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#surf" class="md-nav__link">
    SURF加速鲁棒特征
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#surf_1" class="md-nav__link">
    SURF检测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#u-surf" class="md-nav__link">
    U-SURF检测
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#orb" class="md-nav__link">
    ORB特征检测
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fast" class="md-nav__link">
    FAST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#brief" class="md-nav__link">
    BRIEF
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    尺度和旋转不变性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    特征匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    文档参考
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="07-">07-实现特征检测及描述<a class="headerlink" href="#07-" title="Permanent link">&para;</a></h1>
<h2 id="_1">特征点检测<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>现在，我们已经可以从图像中提取基于形状的特征（如角），但是我们如何实际使用这些特征来检测整个对象呢？特征点又称作特征向量，首先我们看一下一座山的特征。</p>
<p><img alt="" src="../assets/mountain.png" /></p>
<p>假设我们想要一种在其他图像中也能够检测到这座山的方法。 一个角点是不足以在其他图像中识别此山峰，但是，我们可以采用一组特征来定义该山峰的形状，将它们组合为一个数组或矢量，然后使用该组特征来 创建一个山探测器！</p>
<p><img alt="image-20200514182706690" src="../assets/image-20200514182706690.png" /></p>
<p>目标（整座山）的检测依赖着这些特征的检测，我们将这些特征组合在一起，称作“特征向量”。特征向量能够稳定地表示物体的形状。</p>
<p><strong>举个简单的例子：</strong></p>
<p>已此梯形为例，我们已经计算好了梯度和边缘。如果我们将这个图打散成多个图的网格。以梯形为中心为起点，观察每个格子的梯度方向。我们可以将数据平面化，创建出一个一维数组。这个数组就组成了梯形的一个特征向量，这个特征向量就是梯度方向的向量。</p>
<p><img alt="image-20200514185225976" src="../assets/image-20200514185225976.png" /></p>
<p>对圆形也是如此，计算网格中每个格子的梯度方向，这些所有角度所组成的向量就代表了这个圆形。</p>
<p><img alt="image-20200514185243845" src="../assets/image-20200514185243845.png" /></p>
<p>如果要准确地识别任意大小、视角的梯形和圆形，这些向量必须要有一定的<strong>灵活度</strong>，才能在不同场景下识别出同一形状。同时，向量也应该保持足够的<strong>独特性</strong>，才能区分出不同的形状。</p>
<h3 id="_2">特征点检测方法分类<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>人工设计的特征点检测算法：<strong>Harris</strong>、FAST、<strong>SIFT</strong>、SURF、<strong>ORB</strong></p>
</li>
<li>
<p>基于深度学习的检测：人脸关键点，点云特征点</p>
</li>
<li>
<p>人工的标记的特征点：人工贴点、二维码</p>
</li>
</ol>
<h3 id="_3">特征点的要求<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>差异性：可区别于非特征点</p>
<p>重复性：相同的特征点在不同的视角中可以被检测到</p>
<p>鲁棒性：对噪声环境变化的鲁棒性</p>
<p>高效性：具有较高的计算检测效率</p>
<p>纯关键点检测算法：FAST</p>
<p>纯特征描述算法：FREAK、BRIEF、HOG</p>
<p>关键点和特征描述都有：SIFT、SURF、<strong>ORB</strong>（基于FAST, BRIEF）、BRISK</p>
<blockquote>
<p>以下两个算法已被申请专利，所以位于<code>opencv_contrib</code>目录</p>
<p>SIFT：尺度不变特征变换检测</p>
<p>SURF：加速鲁棒特征</p>
</blockquote>
<h2 id="sift">SIFT尺度不变特征变换<a class="headerlink" href="#sift" title="Permanent link">&para;</a></h2>
<p>SIFT（Scale-Invariant Feature Transform）可以翻译为<strong>尺度不变特征变换</strong>，之前我们使用了哈里斯Harris这样的角点检测工具，他们是具有旋转不变形的，这意味着，即使我们把图片进行了旋转，我们仍然能找到相同的角点。因为即使图片旋转了，之前的角点仍旧是角点。但是如果是图片进行了缩放呢？原本一个角点可能就不再是角点了。如下图，原本在小图中的角放大之后，就变成了边缘。</p>
<p><img alt="Scale-Invariance" src="../assets/sift_scale_invariant.jpg" /></p>
<p>因此，在2004年，哥伦比亚大学（ University of British Columbia）的D.Lowe在他的论文《尺度不变关键点中的图像特征》（Distinctive Image Features from Scale-Invariant Keypoints）中提出了一种新的尺度不变特征变换（SIFT）算法，该算法可用于提取关键点并计算其描述符。具体分为以下几个步骤：</p>
<ol>
<li>尺度空间的极值检测</li>
<li>关键点定位</li>
<li>方向分配</li>
<li>关键点描述符</li>
<li>关键点匹配</li>
</ol>
<p>由于该算法已申请了专利，所以这个模块在OpenCV里是非免费的。</p>
<p>英文版论文： https://www.cs.ubc.ca/~lowe/papers/ijcv04.pdf</p>
<p>中文版译文：https://www.cnblogs.com/cuteshongshong/archive/2012/05/25/2506374.html</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;./data/house.jpg&#39;</span><span class="p">)</span>
<span class="n">gray</span><span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

<span class="c1"># 创建SIFT检测器</span>
<span class="n">sift</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">xfeatures2d</span><span class="o">.</span><span class="n">SIFT_create</span><span class="p">()</span>
<span class="c1"># 检测灰度图</span>
<span class="n">kp</span> <span class="o">=</span> <span class="n">sift</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># 绘制检测出的特征点</span>
<span class="c1"># img=cv2.drawKeypoints(gray, kp, None)</span>
<span class="n">img</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">drawKeypoints</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS</span><span class="p">)</span>

<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s2">&quot;dst&quot;</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
<span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">27</span><span class="p">:</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
</code></pre></div>

<ul>
<li>输出结果</li>
</ul>
<p><img alt="dst" src="../assets/dst_screenshot_24.10.2019.png" /></p>
<p>这里<code>sift.detect(gray,None)</code>用来查找图片中的素有关键点，如果希望只在图片中的某个区域查找，则可将掩膜Mask作为第二个参数。每个关键点都是一个特殊的结构对象，具有许多属性，例如其（x，y）坐标，有意义的邻域的大小，描述其方向的角度，描述其关键点强度等。</p>
<p><code>cv2.drawKeypoints</code>函数默认的flags打印参数是<code>cv2.DRAW_MATCHES_FLAGS_DEFAULT</code>，只在关键点上打印圆圈，我们可以传入<code>cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS</code>参数，他会画出一个关键点尺寸大小的圆，并标出其方向信息。</p>
<h2 id="surf">SURF加速鲁棒特征<a class="headerlink" href="#surf" title="Permanent link">&para;</a></h2>
<p>SURF（ (Speeded-Up Robust Features)）可以翻译为<strong>加速鲁棒特征</strong>，之前我们了解了用于关键点检测和描述的SIFT。但是它相对较慢，人们需要更快的版本。 2006年，由Bay, H. 和 Tuytelaars, T. 以及 Van Gool, L三个人发表的另一篇论文《 SURF：加速鲁棒特征》介绍了一种称为SURF的新算法。顾名思义，它是SIFT的加速版本。</p>
<p>在SIFT中，D.Lowe用高斯差、近似高斯的拉普拉斯算子来寻找尺度空间。 SURF走得更远。下图显示了这种近似值的演示。这种近似的一大优势是，借助积分图像可以轻松地计算出带盒滤波器的卷积。并且可以针对不同规模并行执行。 SURF还依赖于Hessian矩阵的行列式来确定规模和位置。</p>
<p><img alt="Box Filter approximation of Laplacian" src="../assets/surf_boxfilter.jpg" /></p>
<p>由于SURF只是SIFT的改进版本，所以所有使用方式和SIFT一致，只是在创建SURF的时候，修改一下创建函数即可。以下为一个原图，我们对其进行检测</p>
<p><img alt="src" src="../assets/butterfly.jpg" /></p>
<h3 id="surf_1">SURF检测<a class="headerlink" href="#surf_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;./data/butterfly.jpg&#39;</span><span class="p">)</span>
<span class="n">gray</span><span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

<span class="c1"># 阈值范围选300-500最好</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">xfeatures2d</span><span class="o">.</span><span class="n">SURF_create</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span>

<span class="c1"># 直接查找关键点和描述符</span>
<span class="n">kp</span><span class="p">,</span> <span class="n">des</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;keypoints1: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kp</span><span class="p">))</span> <span class="c1"># 688</span>

<span class="c1"># 这里共检测到688个点，但是全部显示出来太多了，我们可以调整阈值再次进行检测</span>
<span class="n">surf</span><span class="o">.</span><span class="n">setHessianThreshold</span><span class="p">(</span><span class="mi">30000</span><span class="p">)</span>
<span class="n">kp</span><span class="p">,</span> <span class="n">des</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;keypoints2: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kp</span><span class="p">))</span> <span class="c1"># 49</span>

<span class="c1"># img=cv2.drawKeypoints(gray, kp, None, flags=cv2.DRAW_MATCHES_FLAGS_DEFAULT)</span>
<span class="n">img</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">drawKeypoints</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS</span><span class="p">)</span>

<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s2">&quot;dst&quot;</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
<span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">27</span><span class="p">:</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
</code></pre></div>

<p>可以看到SURF更像是斑点检测器。它检测到蝴蝶翅膀上的白色斑点。我们也可以使用其他图像进行测试。</p>
<p><img alt="dst" src="../assets/butterfly-surf.png" /></p>
<h3 id="u-surf">U-SURF检测<a class="headerlink" href="#u-surf" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;./data/butterfly.jpg&#39;</span><span class="p">)</span>
<span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

<span class="c1"># 阈值范围选300-500最好</span>
<span class="c1"># upright: True表示不计算特征的方向，False反之</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">xfeatures2d</span><span class="o">.</span><span class="n">SURF_create</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="n">upright</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># 直接查找关键点和描述符</span>
<span class="n">kp</span><span class="p">,</span> <span class="n">des</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;keypoints1: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kp</span><span class="p">))</span>  <span class="c1"># 688</span>

<span class="c1"># 这里共检测到688个点，但是全部显示出来太多了，我们可以调整阈值再次进行检测</span>
<span class="n">surf</span><span class="o">.</span><span class="n">setHessianThreshold</span><span class="p">(</span><span class="mi">30000</span><span class="p">)</span>
<span class="n">kp</span><span class="p">,</span> <span class="n">des</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;keypoints2: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kp</span><span class="p">))</span>  <span class="c1"># 49</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">drawKeypoints</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">flags</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS</span><span class="p">)</span>

<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s2">&quot;dst&quot;</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
<span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">27</span><span class="p">:</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
</code></pre></div>

<ul>
<li>输出结果</li>
</ul>
<p><img alt="dst" src="../assets/butterfly-u-surf.png" /></p>
<h2 id="orb">ORB特征检测<a class="headerlink" href="#orb" title="Permanent link">&para;</a></h2>
<p>ORB (Oriented FAST and Rotated BRIEF) 特征</p>
<p>ORB对象识别算法，在增强现实、机器人、SLAM、无人驾驶等方向应用很广泛，这种情况需要实时地处理输入的视频流。ORB算法可以对图像中的关键点快速创建特征向量。然后使用这些特征向量识别图像中的对象。</p>
<p><img alt="image-20200514194148981" src="../assets/image-20200514194148981.png" /></p>
<p>ORB首先会从图像中查找一些特殊的区域，作为关键点，我们可以把关键点看做图像中比较突出的小区域，这些区域的像素值会从浅色急剧地变成深色。下图展示了ORB在这个图像上生成的关键点。我们可以在猫眼睛周围和面部特征的边缘看到这些圆形特征点。</p>
<p><img alt="image-20200514193945766" src="../assets/image-20200514193945766.png" /></p>
<p>当找到这些关键点后，ORB会为每个关键点计算相应的特征向量。ORB算法创建的特征向量只包含1和0，因此我们称之为二元特征向量。1和0的顺序会根据特定关键点和其周围的像素区域而变化。该向量表示关键点周围的强度模式。因此，多个特征向量可以用来识别更大的区域。</p>
<p><img alt="image-20200515113806343" src="../assets/image-20200515113806343.png" /></p>
<p>ORB不仅速度快，而且不受噪点的影响，不受图像旋转、放大的影响。接下来，我们将深入了解Fast和Brief算法的原理。</p>
<h3 id="fast">FAST<a class="headerlink" href="#fast" title="Permanent link">&para;</a></h3>
<p>ORB特征检测的第一步就是查找图像中的关键点，这一步由FAST算法来完成。FAST是<strong>Features from Accelerated Segments Test</strong>的简称。其关键点检测速度很快，是SIFT的100倍，但是原始的检测结果不具有尺度和旋转不变性。</p>
<p><strong>1、确定特征点位置</strong></p>
<p>通过检测局部像素灰度变化来确定特征点的位置</p>
<ol>
<li>以像素点为圆心构建一个离散的圆</li>
<li>比较圆周上的像素与<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>点的像素值差</li>
<li>当有连续的<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>个像素值明显亮于或暗于<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>，则<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>被检测为特征点，Fast9, Fast12</li>
</ol>
<p><strong>2、实现尺度不变性</strong></p>
<p>构建图像金字塔，在金字塔的每一层上检测关键点</p>
<p><strong>3、实现旋转不变性</strong></p>
<p>通过灰度质心法（Intensity Centroid）确定图像的主方向</p>
<p>给定一个图像中的像素<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>，FAST会比较<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>周围小圆圈中的16个像素值。该圆圈的每个像素会被分成三类：比<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>亮、比<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>暗、和<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>相似。我们将像素亮度称为<span><span class="MathJax_Preview">I_p</span><script type="math/tex">I_p</script></span>，即像素的强度（Intensity of pixel p）</p>
<p><img alt="image-20200515110151777" src="../assets/image-20200515110151777.png" /></p>
<p>如果像素亮度为<span><span class="MathJax_Preview">I_p</span><script type="math/tex">I_p</script></span>，则对于指定的阈值<span><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span>，更亮的像素将是亮度超过<span><span class="MathJax_Preview">I_p + h</span><script type="math/tex">I_p + h</script></span>的像素，更暗的像素将是亮度低于<span><span class="MathJax_Preview">I_p - h</span><script type="math/tex">I_p - h</script></span>的像素，相似像素是亮度在两个值之间的像素。</p>
<p>对像素进行分类后，如果圆圈上有8个以上的相连像素亮于或暗于<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>，则将<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>像素选作关键点。FAST高效的原因是仅将<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>与圆圈中的4个等距像素进行对比，其效果与和素有16个周围像素对比的效果一样</p>
<p><img alt="image-20200515110233777" src="../assets/image-20200515110233777.png" /></p>
<p>例如：我们只需将<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>与像素1、 5 、 9、 13进行对比，在这种情况下，如果至少有一对连续像素的亮度高于或低于<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>，则将<span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>选作关键点。这种优化使得在整个图像中搜索关键点的时间缩短了4倍。</p>
<p>这些关键点可以给我们提供什么样的信息呢？对比临近像素的亮度有何意义呢？我们来观察FAST在这个图像上找到的一些关键点。</p>
<p><img alt="image-20200515112141874" src="../assets/image-20200515112141874.png" /></p>
<p>在眼部周围、鼻子周围各有一组关键点，可以看出来关键点位于亮度有变化的区域。此类区域通常确定了某些边缘。比如猫爪子，边缘定义了猫的边界，以及脸部区域的界限。因此这些关键点是我们能够识别这只猫，而不是图像中的其他对象或是背景。</p>
<p><img alt="image-20200515112454717" src="../assets/image-20200515112454717.png" /></p>
<p>所以，通过FAST发现的关键点为我们提供了确定图像中对象的边缘所在位置的信息。但是，这些关键点仅仅提供了边缘的位置，并不包含强度变化方向的信息。接下来我们可以去区分水平和竖直边缘了。现在我们已经知道了ORB如何使用FAST确定图像中的关键点了，我们将了解ORB如何使用BRIEF算法将这些关键点转换成特征向量。</p>
<h3 id="brief">BRIEF<a class="headerlink" href="#brief" title="Permanent link">&para;</a></h3>
<p>ORB算法的第二步是将第一步算法发现的关键点转变成特征向量，这些特征向量可以共同表示一个对象，要创建特征向量，ORB就会用到BRIEF算法。</p>
<p>BRIEF算法是Binary Robust Independent Elementary Features的简称，即二进制健壮的独立基本特征。它的作用是根据一组关键点创建二元特征向量，二元特征向量又称作二元描述子（描述符），是仅包含1和0的特征向量。</p>
<p><img alt="image-20200515113937945" src="../assets/image-20200515113937945.png" /></p>
<p>在BRIEF中，每个关键点由一个二元特征向量描述，该向量有128-512个位，其中仅包含0和1</p>
<p><img alt="image-20200515114155644" src="../assets/image-20200515114155644.png" /></p>
<p>计算机运行的是二进制或机器代码，因此使用二元特征向量的一大优势是可以非常高效地存储在内存中，并且可以快速计算。</p>
<p>这些特性不仅使 BRIEF 速度非常快（速度对实时应用来说极为关键），而且使 BRIEF 能够在计算资源非常有限的设备（例如智能手机）上运行。</p>
<p>BRIEF 如何为每个点创建这些二元描述符？BRIEF 算法首先利用高斯核，对给定图像进行平滑处理，以防描述符对高频噪点过于敏感。</p>
<p><img alt="image-20200515114859985" src="../assets/image-20200515114859985.png" /></p>
<p>接着，对于给定关键点，例如猫爪上的这个点，BRIEF 从该关键点周围界定好的邻域内随机选择一对像素。<strong>关键点周围的邻域称为 Patch</strong>，它是一个具有特定像素宽度和高度的<strong>正方形</strong>，这里显示的随机对中的第一个像素是一个蓝色正方形，它是从以关键点为中心的高斯分布中抽取的一个像素，标准偏差（分散趋势）为 σ。</p>
<p><img alt="image-20200515122744059" src="../assets/image-20200515122744059.png" /></p>
<p>这里显示为黄色正方形的像素是随机对中的第二个像素，它是从以该第一个蓝色像素为中心的高斯分布中抽取的像素，标准偏差为 σ/2，经验表明这种高斯选择，提高了特征匹配率</p>
<p><img alt="image-20200515122657056" src="../assets/image-20200515122657056.png" /></p>
<p>BRIEF 然后开始为关键点构建二元描述符，方法是如下所示地比较这两个像素的亮度，如果第一个像素比第二个亮，则为描述符中的相应位分配值 1，否则分配值 0。</p>
<p><img alt="image-20200515123958729" src="../assets/image-20200515123958729.png" /></p>
<p>在这个示例中，第二个像素比第一个亮，因此我们为特征向量的第一个位分配值 0</p>
<p>特征向量的第一个位对应的是这个关键点的第一个随机点对。</p>
<p>现在 BRIEF 针对同一关键点，选择新的随机像素对，比较它们的亮度并为特征向量中的下个位分配 1 或 0</p>
<p><img alt="image-20200515124100553" src="../assets/image-20200515124100553.png" /></p>
<p>在示例中，我们看到现在第一个像素比第二个亮，因此，为特征向量中的第二个位分配值 1</p>
<p>对于 256 位向量，BRIEF 会针对同一关键点重复这一流程 256 次，然后转到下个关键点，接着将 256 个像素亮度比较结果放入该关键点的二元特征向量中，BRIEF 像这样为图像中的每个关键点创建一个向量。</p>
<p><img alt="image-20200515124154950" src="../assets/image-20200515124154950.png" /></p>
<p>现在我们已经知道 BRIEF 如何为由 FAST 发现的关键点构建特征向量。</p>
<p>接下来，我们将了解 ORB 如何利用这些技巧创建<strong>不受图像旋转、缩放和噪点影响</strong>的向量。</p>
<h3 id="_4">尺度和旋转不变性<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>ORB 使用 FAST 检测图像中的关键点，并且通过额外的几个步骤确保无论对象的大小或位置如何，都能检测到图像中的对象。</p>
<p><strong>尺度不变性</strong></p>
<p><img alt="image-20200515131532055" src="../assets/image-20200515131532055.png" /></p>
<p>给定一个图像，ORB 算法首先开始构建图像金字塔，图像金字塔是单个图像的多尺度表示法。由一系列原始图像的不同分辨率版本组成，金字塔的每个级别都由上个级别的图像下采样版本组成，下采样是指图像分辨率被降低。</p>
<p>在此示例中，图像按照 1/2 比例下采样，因此一开始的 4x4 正方形区域，现在变成 2x2 正方形。
图像的下采样包含更少的像素，并且以 1/2 的比例降低大小，这是一个包含 5 个级别的图形金字塔示例，在每个级别 图像都以 1/2 的比例下采样，到了第四级别，图像的分辨率是原始图像的 1/16。</p>
<p><img alt="image-20200515132209855" src="../assets/image-20200515132209855.png" /></p>
<p>ORB 创建好图像金字塔后，它会使用 FAST 算法从每个级别不同大小的图像中快速找到关键点，因为金字塔的每个级别由原始图像的更小版本组成，因此原始图像中的任何对象在金字塔的每个级别也会降低大小，通过确定每个级别的关键点，ORB 能够有效发现不同尺寸的对象的关键点，这样的话 ORB 实现了部分缩放不变性。
这一点很重要，因为对象不太可能在每个图像中的大小都完全一样，尤其是像猫这样的对象某个时刻可能靠近相机，在另一个时刻离相机很远，甚至躲起来。</p>
<p><img alt="image-20200515132326913" src="../assets/image-20200515132326913.png" /></p>
<p><strong>旋转不变性</strong></p>
<p>现在 ORB 获得了与这个图像金字塔每个级别相关的关键点，在发现金字塔所有级别中的关键点后，ORB 现在为每个关键点分配一个方向，例如朝左或朝右，取决于该关键点周围的强度是如何变化的。</p>
<p><img alt="image-20200515135050208" src="../assets/image-20200515135050208.png" /></p>
<p>我们详细了解下背后原理，ORB 首先选择金字塔级别 0 中的图像，对于该图像 ，ORB 现在将计算关键点的方向
方法是首先计算以该关键点为中心的方框中的强度形心，强度形心可以看做给定 patch 中的平均像素强度的位置
计算强度形心后，通过画一条从关键点到强度形心的向量，获得该关键点的方向，如此处所示，这个关键点的方向是<strong>向下并朝左</strong>，因为这个区域的亮度朝着这个方向增强。</p>
<p>当ORB在计算BRIEF描述子时，就可以以关键点为圆心，以关键点P和强度形心Q的连线作为X轴建立二维坐标系。</p>
<p><img alt="image-20200515174118153" src="../assets/image-20200515174118153.png" /></p>
<p>在图1中，P为关键点。圆内为取点区域，每个小格子代表一个像素。现在我们把这块圆心区域看做一块木板，木板上每个点的质量等于其对应的像素值。根据积分学的知识我们可以求出这个密度不均匀木板的质心Q。计算公式如下。其中R为圆的半径。</p>
<div>
<div class="MathJax_Preview">
M_{00}=\sum_{x=-R}^{R} \sum_{Y=-R}^{R} I(x, y)
</div>
<script type="math/tex; mode=display">
M_{00}=\sum_{x=-R}^{R} \sum_{Y=-R}^{R} I(x, y)
</script>
</div>
<div>
<div class="MathJax_Preview">
M_{10}=\sum_{Y=-R}^{R} \sum_{X=-R}^{R} x I(x, y)
</div>
<script type="math/tex; mode=display">
M_{10}=\sum_{Y=-R}^{R} \sum_{X=-R}^{R} x I(x, y)
</script>
</div>
<div>
<div class="MathJax_Preview">
M_{01}=\sum_{X=-R}^{R} \sum_{Y=-R}^{R} y I(x, y)
</div>
<script type="math/tex; mode=display">
M_{01}=\sum_{X=-R}^{R} \sum_{Y=-R}^{R} y I(x, y)
</script>
</div>
<div>
<div class="MathJax_Preview">
Q_{X}=\frac{M_{10}}{M_{00}}, Q_{Y}=\frac{M_{01}}{M_{00}}
</div>
<script type="math/tex; mode=display">
Q_{X}=\frac{M_{10}}{M_{00}}, Q_{Y}=\frac{M_{01}}{M_{00}}
</script>
</div>
<p>我们知道圆心是固定的而且随着物体的旋转而旋转。当我们以PQ作为坐标轴时（图2），在不同的旋转角度下，我们以同一取点模式取出来的点是一致的。这就解决了旋转一致性的问题。</p>
<p>为金字塔级别 0 的图像中的每个关键点分配方向后，ORB 现在为所有其他金字塔级别的图像重复相同流程，需要注意的是，<strong>在每个图像金字塔级别，Patch 大小没有缩减</strong>，因此，相同 Patch 在较小的金字塔级别，其覆盖的图像区域将更大，导致关键点的大小各不相同，可以从此处看出这一点。即较大的圆形关键点是在较小的金字塔层级中检测出来的。</p>
<p><img alt="image-20200515135541617" src="../assets/image-20200515135541617.png" /></p>
<p>在此图中，圆圈表示每个关键点的大小，更高的金字塔级别中的关键点大小更大，找到关键点并为其分配方向后，
ORB 现在使用修改后的 BRIEF 版本创建特征向量，这个修改后的 BRIEF 版本称为 rBRIEF，即 Rotation-Aware BRIEF。无论对象的方向如何，它都可以为关键点创建相同的向量，使得 ORB 算法具有旋转不变性，意味着它可以在朝着任何角度旋转的图像中检测到相同的关键点。
和 BRIEF 一样， rBRIEF 首先在给定关键点周围的已界定 patch 中，随机选择 256 个像素对，以构建 256 位向量，然后根据关键点的方向角度旋转这些随机像素对，使随机点的方向与关键点的一致。最后， rBRIEF 对比随机像素对的亮度，并相应地分配 1 和 0 创建对应的特征向量。<strong>为图像中的所有关键点创建的所有特征向量集合，称之为 ORB 描述符</strong></p>
<h3 id="_5">特征匹配<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p><strong>距离度量</strong></p>
<ul>
<li>欧氏距离</li>
</ul>
<blockquote>
<p>大部分特征都用的是欧氏距离，计算两个向量之间每个维度的差值的平方和</p>
</blockquote>
<div>
<div class="MathJax_Preview">
\begin{equation}
 D_{e u c}(\boldsymbol{a}, \boldsymbol{b})=\|\boldsymbol{a}-\boldsymbol{b}\|_{2}=\left(\sum_{i=1}^{n}\left(a_{i}-b_{i}\right)^{2}\right)^{\frac{1}{2}} 
\end{equation}
</div>
<script type="math/tex; mode=display">
\begin{equation}
 D_{e u c}(\boldsymbol{a}, \boldsymbol{b})=\|\boldsymbol{a}-\boldsymbol{b}\|_{2}=\left(\sum_{i=1}^{n}\left(a_{i}-b_{i}\right)^{2}\right)^{\frac{1}{2}} 
\end{equation}
</script>
</div>
<div>
<div class="MathJax_Preview">
\begin{equation}
 D_{s s d}(\boldsymbol{a}, \boldsymbol{b})=\|\boldsymbol{a}-\boldsymbol{b}\|_{2}^{2}=D_{e u c}(\boldsymbol{a}, \boldsymbol{b})^{2} 
\end{equation}
</div>
<script type="math/tex; mode=display">
\begin{equation}
 D_{s s d}(\boldsymbol{a}, \boldsymbol{b})=\|\boldsymbol{a}-\boldsymbol{b}\|_{2}^{2}=D_{e u c}(\boldsymbol{a}, \boldsymbol{b})^{2} 
\end{equation}
</script>
</div>
<ul>
<li>马氏距离</li>
</ul>
<blockquote>
<p>较少用，针对特定场景，通过 <span><span class="MathJax_Preview">\Sigma</span><script type="math/tex">\Sigma</script></span> 为每个维度分配一些权重</p>
</blockquote>
<div>
<div class="MathJax_Preview">
\begin{equation}
D_{\text {mahal }}(\boldsymbol{a}, \boldsymbol{b})=\left((\boldsymbol{a}-\boldsymbol{b})^{T} \sum^{-1}(\boldsymbol{a}-\boldsymbol{b})\right)^{\frac{1}{2}} 
\end{equation}
</div>
<script type="math/tex; mode=display">
\begin{equation}
D_{\text {mahal }}(\boldsymbol{a}, \boldsymbol{b})=\left((\boldsymbol{a}-\boldsymbol{b})^{T} \sum^{-1}(\boldsymbol{a}-\boldsymbol{b})\right)^{\frac{1}{2}} 
\end{equation}
</script>
</div>
<ul>
<li>汉明距离</li>
</ul>
<div>
<div class="MathJax_Preview">
\begin{equation}
D_{h a m}(\boldsymbol{a}, \boldsymbol{b})=\sum_{i=1}^{n} a_{i} \oplus b_{i} 
\end{equation}
</div>
<script type="math/tex; mode=display">
\begin{equation}
D_{h a m}(\boldsymbol{a}, \boldsymbol{b})=\sum_{i=1}^{n} a_{i} \oplus b_{i} 
\end{equation}
</script>
</div>
<p><span><span class="MathJax_Preview">\oplus</span><script type="math/tex">\oplus</script></span>表示异或</p>
<blockquote>
<p>汉明距离是以理查德·卫斯里·汉明的名字命名的。在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。例如：</p>
<p>1011101 与 1001001 之间的汉明距离是 2。</p>
<p>2143896 与 2233796 之间的汉明距离是 3。</p>
<p>"toned" 与 "roses" 之间的汉明距离是 3。</p>
</blockquote>
<p>ORB算法最大的特点就是计算速度快 。 这首先得益于使用FAST检测特征点，FAST的检测速度正如它的名字一样是出了名的快。再次是使用BRIEF算法计算描述子，该描述子特有的2进制串的表现形式不仅节约了存储空间，而且大大缩短了匹配的时间。</p>
<p>例如特征点A、B的描述子如下。</p>
<p>A：10101011</p>
<p>B：10101010</p>
<p>我们设定一个阈值，比如80%。当A和B的描述子的相似度大于90%时，我们判断A,B是相同的特征点，即这2个点匹配成功。在这个例子中A,B只有最后一位不同，相似度为87.5%，大于80%。则A和B是匹配的。</p>
<p>我们将A和B进行异或操作就可以轻松计算出A和B的相似度。而异或操作可以借组硬件完成，具有很高的效率，加快了匹配的速度。</p>
<p>我们已经知道 ORB 算法的原理，但可能会疑问到底可以如何使用 ORB 描述符进行对象识别呢？我们来看一个示例以了解 ORB 如何检测到具有不同大小和方向的同一对象。
假设我想在其他图像中检测到此人的面孔，例如在这个多人合影中，我们将第一张图像称为训练图像，第二张图像，即要对其进行人脸检测的图像，称为查询图像。</p>
<p><img alt="img" src="../assets/1661825-20190814210519810-1074702194.png" /></p>
<p>给定这个训练图像，我想在这个查询图像中查找相似的特征，第一步是计算训练图像的 ORB 描述符并将其存储到内存中。</p>
<p><img alt="img" src="../assets/1661825-20190814210540417-879073719.png" /></p>
<p>ORB 描述符将包含二元特征向量，用于描述这个训练图像中的关键点。第二步是计算并保存查询图像的 ORB 描述符，获得训练和查询图像的描述符后，最后一步是使用相应的描述符对这两个图像进行关键点匹配，通常使用匹配函数来完成这一步。
匹配函数的目的是匹配两个不同图像的关键点，方法是比较这两个图像的描述符，看看它们是否很相近可以匹配。当匹配函数对比两个关键点时，它会根据某种指标得出匹配质量，这种指标表示关键点特征向量的相似性。可以将这个指标看作与两个关键点之间的<strong>标准欧几里得距离</strong>相似性。某些指标会直接检测特征向量是否包含相似顺序的 1 和 0。需要注意的是，不同的匹配函数使用不同的指标来判断匹配质量。对于 ORB 等使用的二元描述符来说，通常使用<strong>汉明指标</strong>，因为它执行起来非常快。
汉明指标通过计算二元描述符之间的不同位数量判断两个关键点之间的匹配质量。在比较训练图像和查询图像的关键点时，差异数最少的关键点对被视为最佳匹配。匹配函数对比完训练图像和查询图像中的所有关键点后，返回最匹配的关键点对。</p>
<p><img alt="img" src="../assets/1661825-20190814210556958-1092173300.png" /></p>
<p>我们的训练图像和查询图像之间的最匹配点显示在此处，可以清晰地看出训练图像和查询图像之间最匹配的点主要对应的是训练图像的面孔。有一两个特征不是太匹配，原因可能是该图像区域的强度模式比较相似。因为大部分点对应的是训练图像中的脸部，可以看出匹配函数能够在查询图像中正确地识别该面孔。</p>
<h3 id="_6">文档参考<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<p>关于ORB的最重要的事情是它来自“ OpenCV Labs”。该算法由Ethan Rublee，Vincent Rabaud，Kurt Konolige和Gary R. Bradski在他们的论文《 <strong>ORB: An efficient alternative to SIFT or SURF</strong>》于2011年提出。正如标题所述，它是SIFT和SURF的良好替代方案，其计算消耗和匹配性能是其专利。不过，SIFT和SURF已获得专利，您应该为其使用付费。但是，ORB不是！</p>
<p>英文论文：https://www.researchgate.net/publication/221111151_ORB_an_efficient_alternative_to_SIFT_or_SURF</p>
<p>中文翻译：https://blog.csdn.net/u011344545/article/details/80421915</p>
<p>ORB基本上是FAST关键点检测器和Brief描述符的融合，并进行了许多修改以增强性能。首先，它使用FAST查找关键点，然后应用哈里斯Harris角点度量在其中找到前N个点。它还使用金字塔生成多尺度特征。</p>
<h3 id="_7">代码实现<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;./data/blox.jpg&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># 初始化ORB检测器</span>
<span class="n">orb</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">ORB_create</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>

<span class="c1"># 使用ORB查找检点</span>
<span class="n">kp</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># 使用ORB计算描述符</span>
<span class="n">kp</span><span class="p">,</span> <span class="n">des</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">kp</span><span class="p">)</span>

<span class="c1"># 绘制关键点，忽略尺寸和方向</span>
<span class="n">img2</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">drawKeypoints</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img2</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<ul>
<li>输出结果</li>
</ul>
<p><img alt="dst" src="../assets/blox_orb.png" /></p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../07-corner_detection/" title="07-角点检测" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                07-角点检测
              </span>
            </div>
          </a>
        
        
          <a href="../08-feature_matching/" title="08-特征匹配" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                08-特征匹配
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            <a href="https://www.czxy.com/">传智专修学院</a> 版权所有 2006 - 2020 江苏传智播客教育科技股份有限公司  学校地址：江苏省宿迁市沭阳县北京南路6号  邮编：223600   <a href="http://www.beian.miit.gov.cn/">苏ICP备16007882号-4</a>
          </div>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.c33a9706.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
              
            
          
          
        
      
      <script>app.initialize({version:"1.1",url:{base:"../.."}})</script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="https://lib.baomitu.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
        <script src="../../js/baidu-tongji.js"></script>
      
        <script src="../../js/baidu-tuisong.js"></script>
      
    
  </body>
</html>